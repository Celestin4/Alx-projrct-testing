#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

#define MAX_LINE 80
#define MAX_ARGS 20
#define MAX_PATHS 10
#define MAX_PATH_LEN 50
#define BUFFER_SIZE 512


extern char **environ;

char *paths[MAX_PATHS];
int num_paths = 0;

#define MAX_ALIASES 10
#define MAX_ALIAS_LEN 20
#define MAX_COMMAND_LEN 80

struct alias_entry {
    char alias[MAX_ALIAS_LEN + 1];
    char command[MAX_COMMAND_LEN + 1];
};

struct alias_entry aliases[MAX_ALIASES];
int num_aliases = 0;
 
void add_path(char *path) {
    if (num_paths < MAX_PATHS) {
        paths[num_paths++] = path;
    }
}

char *find_command(char *command) {
    int i;
    char *path, *full_path;
    struct stat st;
    for (i = 0; i < num_paths; i++) {
        path = paths[i];
        full_path = malloc(strlen(path) + strlen(command) + 2);
        sprintf(full_path, "%s/%s", path, command);
        if (stat(full_path, &st) == 0 && (st.st_mode & S_IXUSR)) {
            return full_path;
        }
        free(full_path);
    }
    return NULL;
}

int execute_command(char **args) {
    char *command = args[0];
    char *full_path = find_command(command);
    if (full_path == NULL) {
        printf("%s: command not found\n", command);
        return 0;
    }
    pid_t pid = fork();
    if (pid == 0) {
        execve(full_path, args, NULL);
        printf("execve failed\n");
        exit(1);
    }
    int status;
    waitpid(pid, &status, 0);
    return WIFEXITED(status) && !WEXITSTATUS(status);
}

void add_alias(char *alias, char *command) {
    if (num_aliases < MAX_ALIASES) {
        strncpy(aliases[num_aliases].alias, alias, MAX_ALIAS_LEN);
        strncpy(aliases[num_aliases].command, command, MAX_COMMAND_LEN);
        num_aliases++;
    } else {
        printf("add_alias: too many aliases\n");
    }
}


int execute_line(char *line) {
    char *args[MAX_ARGS];
    int num_args = 0;
    char *arg = strtok(line, " ;\n"); // use " ;\n" as the delimiter
    while (arg != NULL && num_args < MAX_ARGS - 1) {
        args[num_args++] = arg;
        arg = strtok(NULL, " ;\n");
    }
    args[num_args] = NULL;

    if (num_args == 0) {
        return 0;
    }

    int i = 0;
    int success = 1; // flag to track success or failure of previous command
    while (args[i] != NULL) {
        if (strcmp(args[i], "exit") == 0) {
            // handle "exit" command
            printf("Goodbye!\n");
            exit(0);
        } else if (strcmp(args[i], "env") == 0) {
            // handle "env" command
            char **p;
            for (p = environ; *p; p++) {
                printf("%s\n", *p);
            }
        } else if (strcmp(args[i], "setenv") == 0) {
            // handle "setenv" command
            if (args[i+1] != NULL && args[i+2] != NULL) {
                if (setenv(args[i+1], args[i+2], 1) != 0) {
                    perror("setenv");
                }
            } else {
                printf("setenv: invalid arguments\n");
                success = 0;
            }
            i += 2;
        } else if (strcmp(args[i], "unsetenv") == 0) {
            // handle "unsetenv" command
            if (args[i+1] != NULL) {
                if (unsetenv(args[i+1]) != 0) {
                    perror("unsetenv");
                }
            } else {
                printf("unsetenv: invalid arguments\n");
                success = 0;
            }
            i++;
        } else if (strcmp(args[i], "cd") == 0) {
            // handle "cd" command
            if (args[i+1] != NULL) {
                if (chdir(args[i+1]) != 0) {
                    perror("cd");
                    success = 0;
                }
            } else {
                printf("cd: invalid arguments\n");
                success = 0;
            }
            i++;
        } else if (strcmp(args[i], "&&") == 0) {
            // handle "&&" operator
            if (!success) {
                // if the previous command failed, skip the next command
                i++;
            }
        } else if (strcmp(args[i], "||") == 0) {
            // handle "||" operator
            if (success) {
                // if the previous command succeeded, skip the next command
                i++;
            }
        } else {
            // execute the command
            success = execute_command(args + i);
        }
        i++;
    }
    return success;
}



char *my_getline(void) {
    static char buffer[BUFFER_SIZE];
    static int pos = 0;
    static int len = 0;
    char *line;

    line = malloc(sizeof(char) * (BUFFER_SIZE + 1));
    if (!line) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    while (1) {
        if (pos >= len) {
            len = read(STDIN_FILENO, buffer, BUFFER_SIZE);
            if (len <= 0) {
                free(line);
                return NULL;
            }
            pos = 0;
        }
        if (buffer[pos] == '\n') {
            line[pos] = '\0';
            pos++;
            return line;
        } else {
            line[pos] = buffer[pos];
            pos++;
        }
    }
}

void read_rc_file() {
    char *home = getenv("HOME");
    if (home == NULL) {
        return;
    }
    char rcfile[MAX_PATH_LEN];
    sprintf(rcfile, "%s/.myshellrc", home);
    FILE *f = fopen(rcfile, "r");
    if (f == NULL) {
        return;
    }
    char line[MAX_LINE];
    while (fgets(line, MAX_LINE, f) != NULL) {

        execute_line(line);
    }
    fclose(f);
}

int get_exit_status(pid_t pid) {
    int status;
    do {
        if (waitpid(pid, &status, 0) == -1 && errno != EINTR) {
            return -1;
        }
    } while (pid == -1 && errno == EINTR);
    return WEXITSTATUS(status);
}

int main() {
    // your code here
    return 0;
}


char *replace_variables(char *str) {
    char *result = NULL;
    int len = strlen(str);
    int i, j, k;

    result = (char *) malloc(len + 1);

    if (result == NULL) {
        return NULL;
    }

    for (i = 0, j = 0; i < len; i++) {
        if (str[i] == '$') {
            if (str[i+1] == '?') {
                result[j++] = '0' + (int) (get_exit_status() / 10);
                result[j++] = '0' + (int) (get_exit_status() % 10);
                i++;
            } else if (str[i+1] == '$') {
                int pid = getpid();
                char pid_str[20];
                snprintf(pid_str, 20, "%d", pid);
                for (k = 0; pid_str[k] != '\0'; k++) {
                    result[j++] = pid_str[k];
                }
                i++;
            } else {
                result[j++] = str[i];
            }
        } else {
            result[j++] = str[i];
        }
    }

    result[j] = '\0';

    return result;
}

int main() {
    add_path("/bin");
    add_path("/usr/bin");
    read_rc_file();
    while (1) {
        printf("$ ");
        fflush(stdout);
        char *line = my_getline();
        if (line == NULL) {
            break;
        }
        execute_line(line);
        free(line);
    }
    return 0;
}
